## TCP
工作在传输层，是一种面向连接的、可靠的、基于字节流的传输层通信协议
### TCP三次握手
![TCP建立连接示意图](https://images2018.cnblogs.com/blog/1158196/201803/1158196-20180301191116528-1173543278.png)
  1. 服务端通过socket，bind和listen准备好接受外来的连接，此时服务端状态为Listen
  2. 客户端通过调用connect来发起主动连接，导致客户端TCP发送一个SYN（同步）字节，告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号，客户端状态为SYN_SENT
  3. 服务器确认（ACK）客户的SYN，并自己也发送一个SYN，它包含服务器将在同一连接中发送数据的初始序列号
  4. 客户端确认服务的ACK和SYN，向服务器发送ACK，客户端状态ESTABLISHED
  5. 服务器接收ACK,服务器状态ESABLISHED

### TCP四次挥手
![TCP断开连接示意图](https://images2018.cnblogs.com/blog/1158196/201803/1158196-20180301191028587-1027330495.png)
  1. 某端首先调用close，成为主动关闭端，向另一端发送FIN分节，表示数据发送完毕，此时主动关闭端状态FIN_WAIT_1
  2. 接收到FIN的是被动关闭端，FIN由TCP确认，先向主动关闭端发送ACK，作为一个文件结束符传递给接收端应用进程（放在已排队等候该应用进程接收到的任何其他数据之后），因为FIN的接收意味着接收端应用进程在相应连接无额外数据可接收，接收端状态CLOSE_WAIT；主动关闭端接收到ACK状态变为FIN_WAIT_2
  3. 一段时间后，接收端接收到这个文件结束符的应用进程调用close关闭套接字，向主动关闭端发送FIN，接收端状态为LAST_ACK
  4. 主动关闭端确认FIN，状态变为TIME_WAIT，并向接收端发送ACK，接收端接收到ACK关闭TCP，而主动关闭端一段时间后也关闭TCP

[参考：TCP建立与断开连接](https://www.cnblogs.com/dj0325/p/8490293.html)

### TCP与UDP的区别
  1. TCP面向连接，UDP面向数据报
  2. TCP保证有序数据传输，UDP不保证
  3. TCP是可靠的传输，UDP会出现丢包
  4. TCP提供阻塞/流量控制，UDP没有
  5. TCP适用于可靠性要求高的传输，数据量大，传输时间要求低的场景；UDP适用于时间要求高，可靠性要求低，数据量较少的场景
  
### HTTP的长连接与短连接
HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据（一般请求头有Connection: keep-alive）；相反的就是短连接。如果HTTP1.1版本的HTTP请求报文不希望使用长连接，则要在HTTP请求报文首部加上Connection: close。

客户端的长连接不可能无限期的拿着，会有一个超时时间，服务器有时候会告诉客户端超时时间，譬如Keep-Alive: timeout=20，表示这个TCP通道可以保持20秒。另外还可能有max=XXX，表示这个长连接最多接收XXX次请求就断开。还有Content-length: xxx，表示接收数据长度达到一定数值服务器就断开长连接。

对于客户端来说，如果服务器没有告诉客户端超时时间也没关系，服务端可能主动发起四次握手断开TCP连接，客户端能够知道该TCP连接已经无效；另外TCP还有心跳包来检测当前连接是否还活着，方法很多，避免浪费资源。

